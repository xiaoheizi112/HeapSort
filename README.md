# 堆排序算法实现

## 项目简介

这是一个用C语言实现的堆排序算法项目。堆排序是一种基于堆数据结构的高效排序算法，具有O(n log n)的时间复杂度，是一种不稳定但高效的排序方法。

## 算法思路

堆排序的核心思想是：
1. **构建大顶堆**：将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点
2. **交换元素**：将堆顶元素与末尾元素进行交换，此时末尾就是最大值
3. **重新调整**：将除最后一个元素外的所有元素重新构造成一个堆，得到次大值
4. **重复过程**：如此反复执行，就可以得到一个有序的序列

## 代码功能

### 主要函数

- **Swap(int *x, int *y)**: 元素交换函数
  - 功能：交换两个整数的值
  - 实现：使用临时变量进行安全交换

- **AdjustHeap(int *p, int root, int index)**: 堆调整函数
  - 参数：数组指针、根节点下标、数组最后元素下标
  - 功能：维护大顶堆的性质，确保父节点大于子节点
  - 核心逻辑：从指定根节点开始，向下调整堆结构

- **HeapSort(int *p, int len)**: 堆排序主函数
  - 参数：数组指针、数组长度
  - 功能：执行完整的堆排序过程
  - 实现步骤：
    1. 构建初始大顶堆（从最后一个父节点开始）
    2. 反复交换堆顶与末尾元素，并重新调整堆

- **PrintfArray(int *p, int len)**: 数组打印函数
  - 功能：格式化输出数组中的所有元素

### 程序特点

1. **大规模数据测试**: 程序生成1000个0-499范围内的随机数进行排序
2. **随机数种子**: 使用`srand(time(NULL))`确保每次运行生成不同的测试数据
3. **完整实现**: 包含堆的构建、调整和排序的完整过程
4. **清晰注释**: 代码中包含关键步骤的注释说明

## 算法复杂度

- **时间复杂度**:
  - 构建堆：O(n)
  - 排序过程：O(n log n)
  - 总体：O(n log n)

- **空间复杂度**: O(1) - 原地排序算法

## 堆的基本概念

### 大顶堆性质
- 父节点的值总是大于或等于其子节点的值
- 堆顶元素是整个堆中的最大值
- 完全二叉树结构

### 数组表示
- 对于下标为i的节点：
  - 左子节点下标：2*i + 1
  - 右子节点下标：2*i + 2
  - 父节点下标：(i-1)/2

## 编译和运行

```bash
# 编译
gcc HeapSort.c -o heapsort

# 运行
./heapsort
```

## 输出示例

程序运行后会输出排序后的1000个数字，按从小到大的顺序排列：
```
0 1 2 3 4 5 6 7 8 9 10 11 12 ...
```

## 算法优势

1. **时间复杂度稳定**: 无论最好、平均还是最坏情况，时间复杂度都是O(n log n)
2. **原地排序**: 只需要常数级别的额外空间
3. **不依赖输入**: 性能不受输入数据分布影响
4. **实用性强**: 在需要稳定性能的场景中表现优秀

## 算法特点

### 优势
- **效率高**: O(n log n)的时间复杂度
- **空间省**: 原地排序，空间复杂度O(1)
- **性能稳定**: 最坏情况下仍保持O(n log n)

### 劣势
- **不稳定**: 相等元素的相对位置可能改变
- **常数因子**: 实际运行时间可能比快速排序慢
- **缓存不友好**: 堆调整过程中的内存访问模式不连续

## 应用场景

1. **优先队列**: 堆排序的核心数据结构
2. **Top-K问题**: 找出最大或最小的K个元素
3. **实时系统**: 需要稳定性能保证的排序场景
4. **内存受限**: 不能使用额外空间的排序需求

## 学习价值

1. **数据结构理解**: 深入理解堆这一重要数据结构
2. **算法设计**: 学习分治思想在排序中的应用
3. **性能分析**: 理解时间和空间复杂度的权衡
4. **实际应用**: 掌握堆在实际问题中的应用方法